
This is normally found at the start of bash files.: `#/bin/bash`. The 'shebang': `#!` Must be followed with the path the the interpreter. It is a convention in Linux shells. PowerShell seems to figure it out by the extension though. Then you can just execute the script by just writing the file path, rather than bash path

To assign a value to a variable, the variable name is followed by the assignment operator (=) and the value. For example, `VARIABLE=value.` Cannot use spaces in variable assignment. Must use `local VARIABLE=value.` before any variable assignment to enforce local variables.

To access the value stored in a variable, the variable name is preceded by a dollar sign ($). For example, `echo $VARIABLE`

To use the value of a variable in a string, the variable name is enclosed by curly braces {} and preceded by a dollar sign. For example, echo "The value of the variable is `${VARIABLE}"`

In bash, `$(command)` is used to execute the command inside the parenthesis and substitute the output of that command in place of the expression. It is known as command substitution. For example, echo Today is $(date) will execute the date command and substitute the output in place of $(date) so the output will be like "Today is Mon Jan 16 15:12:43 PST 2022"

To use or set an environment variable in a script, you should prefix the variable with export keyword. `export MY_ENV_VAR="Hello World"`. Now in the shell, this variable will be available. Environment variables are only available for the current session

You can use a here-doc to include the contents of another file in a bash script. You can use cat command and the here-doc notation to include the contents of a file in your script, like this:

```
cat << EOF
$(cat /path/to/file)
EOF
```

Gets the first match of a file glob:

```
Echo $(ls -1 .txt)
```


## .profile and .bashrc

These scripts run every time you log in and are used to export variables and paths into the shell. Necissary to add the conda executable to the path here.

`.bashrc` are specific to `bash`, whereas `.profile` is read by many shells in the absence of their own shell-specific config files.

The idea behind this was that one-time setup was done by `.profile` (or shell-specific version thereof), and per-shell stuff by `.bashrc`.


 ---
## Variables 

> All variables are strings!


### Variables are called with `$`


```
$textstring # a named variable
$?          # status code of last command
$#          # number of varibles
$1          # first positional variable
$2          # second positional variable
$0          # -bash if called from in interactive terminal, even if from a function sourced from a file, 
	        # ./rel/path/to/file.sh if referenced inside a script with #!/bin/bash at the top
```

## Variables are assigned with "="

These all mean assign the value of $b to a. Let b be hello

```bash
$ a="$b"
$ echo a
hello
```

```bash
$ a=$b
$ echo a
hello
```


The single quotes '' mean raw string:
```bash
$ a='$b'
$ echo $a
$b
```


### Integer addition and subtraction with number strings with `$(())` 

```bash 
$ a=1
$ b=2
$ echo $((a+b))
3
```

It cannot even handle decimal numbers or scientific notation


---

## Functions

Functions return exit codes BUT, they assign the contents of the `echo` command to the variable 

This gets the string

```
a=afunction()
```

This gets the exit code 

```
$ afunction()
a=$?
```


### Function Exit codes

The `return` in functions is always an integer value from 0 to 255.  0 means success, 1 means generic error.

> The `return` value is the exit code, the `echo` value is assigned to variables!

Unless you explicitly use the `exit` command with a specific exit code like `exit 1` or `exit 2` (or any other non-zero value), the default exit code for a script or program when it reaches the end of its execution is 0. This convention is used in many programming languages and shell scripts to indicate successful execution.


```
0 # always success. Default and means the script ran without errors. 
1 # generic error
2 to n # specific error. onwards are custom exit codes for bash that you generally associate with a message to indicate specific outcomes.
non
```


In an if statement, you literally just put the function: 

```bash
if my_function; then 
	echo "Success, exit code 0" 
else 
	 echo "Failure, exit code non-zero" 
fi
```



---

## Conditions and Equality

```
[ a = b ] # code 0 if true , code 1 if false 
[ a -eq b ] # code 0 if true , code 1 if false 
# == is bash only, not zsh or fish

```

---




---

